
Port test helpers to fix determinism and reduce C dependencies. Maybe even add upload?

Add server JSON endpoint

Add security policies

Add riapi converter (basic)

Add server configuration via TOML (or JSON API?) We need a form of persistence that is lightweight and not always tied to the filesystem.


Multi-tenanting by subdomain (host mapping), port, or folder.

Mapping folders (or even the root!) to data sources, like another HTTP server.
Reserved endpoints for fully encoded arbitrary requests, though, where we can pass through auth info to the upstream gateway






















### For troubleshooting and reporting panics.

--troubleshoot-package [optional file name - otherwise use current params set to create it]

Add a 'troubleshooting' module which can load (or use) one of these data structures, then perform various transformations on it.
We'll call these experiments. The experiments will help narrow down the problem area, or shrink the repro case.

If the unmodified job fails, but the translated/portable job has a different error (or none), then it may be I/O related.
If the translated job fails, but we can read dimensions of all input images and decode them, then it is related to the job.
If we replace jpegs with blank jpegs of the same size, and 24 and 32-bit PNGs with  blank 24 and 32-bit PNGs of the same size,
and the error is not reproduced, then we know that a detail of the original files is triggering it. If the error is reproduced,
then we can further shrink the problem.
We can then use 3x3 (or a tiny, but similar ratio size to original) images, and see if the problem is still reproduced.
We can then (whether 3x3 works or not, or blanks work or not), start deleting nodes from the encoders inward,
until we get a success.
When calling the child imageflow_tool process, we must differentiate between JSON syntax errors and true panics. Thus
we should return JSON for errors that are unquestionably the user's and use a different exit code.

We store the results of these experiments in JSON, but also in a plain-text human readable summary.
If we have record of previous experiments results from a different platform, we show a table of comparisons on succeed/fail and exit codes.


We store the commit ID of imageflow_tool used alone in a file named "imageflow_commit_id" in the root of the .zip package.

We upload to S3, and have CreateObject trigger an AWS lambda.
AWS lambda fetches package, then fetches the Imageflow build for that commit ID and a matching glibc. We run that
imageflow_tool in --troubleshoot-package mode against the uploaded file, and let it augment the report on a different OS.
We then ship that report to nathanael.jones@gmail.com, or some other system, and upload the
complete pacakge (perhaps in interactive HTML form) to Amazon S3 again.

If we want to store image output for multiple experiments, we should rename them to their checksum and edit the experiment JSON.

We could also enable graph exporting, and store that result for each experiment.
Rendering with https://stackoverflow.com/questions/22595493/reading-dot-files-in-javascript-d3 ?

We need to be able to 'fast-forward' a case to a newer commit; see if it changes.

.zip files are the universal container format: https://mvdnes.github.io/rust-docs/zip-rs/zip/write/struct.ZipWriter.html
compression quality doesn't matter much.

We will end up with many columns (rows per experiment), including (original version on user OS), (linux, same version), (linux, latest version). (linux, latest version that doesn't fail), (linux, next failing version)

 We want an S3 listing that makes it easy to go through and fast-forward everything. Should we use UTC date of plus a hash? Shuffle forward based on success?





## For troubleshooting visual bugs

- Let the user try png32 output first.

- These can also be platform-specific.

- for certain known graphs we could craft an equivalent ImageMagick command/script and the compare the result

--result-is-wrong





Create constraint node
https://github.com/riapi/riapi/blob/master/level-1.md
width/height/mode/scale/anchor

Create server

Create RIAPI wrapper

Create backend-agnostic Client API (takes binary blobs online). It can use FFI, server, or command-line tool.


* GIF codec
* Animated GIF codec
* quantization API
* Composition API
* White balance API
* cost estimation


Refine the JSON API

Reconsider graph_recording design
Reconsider no_gamma_correction flag placement



We probably need a way for clients to hint they're going to reuse an input soon

-----

Port visual helpers to Rust and add upload support. Make more general, add JSON support?

Put all graph recording results in a graph_recording subfolder

Test pulling from a decoder into several different nodes

Roundtrip and compare various things (like flips)


## Unhappy path work below
-------------------------

4. Validate nodes/inputs/outputs

Define error handling convention

Rust panic sources
* OOM panics, but we want to rescue it.
* Some invalid input will panic (most, until later in development)
* Bugs should panic (but some may fail Result instead)

Context error sources:
* OOM
* I/O error
* Not implemented
* Invalid/null argument, invalid dimensions/format, other invalid args
* Encoding/decoding failed
* Item does not exist

Rust error sources:
* JSON parsing error
* Node validation
* Graph validation
* lots of other things

Constraints:
* Panics must *always* be caught at the FFI boundary
* Panics and unwinding are expensive, and should never happen in normal situations.

Hacks
* We can change the value Panics-on-OOM provide, to treat them differently.
* backtrace-rs lets us resolve symbols/filenames/line numbers directly.


Thoughts:
Mirror JSON and Context error data, always. If a message doesn't have a successful response, they need to call
clear_error. We can probably condense status codes, though.




Don't panic on bad JSON or input; return a Result, and get it right.

It's okay to panic on OOM, but catch it


## Rust todo

Error 0495 is missing from the compiler error index
https://is.gd/Y228qT

Examples of visibility and access would be good
Examples of &mut self issues and resolutions
Examples of 'static being the default for owned types, etc.


### Bugs

(cd ./target/debug/grind_visuals-289e0d4add8b75f1 && valgrind -q --error-exitcode=9 --gen-suppressions=all ../visuals-289e0d4add8b75f1)

running 15 tests
==13229== Thread 9 test_fill_rect_original:
==13229== Invalid read of size 1
==13229==    at 0x4C2EAA1: strcmp (vg_replace_strmem.c:842)
==13229==    by 0x5F36EF: visual_compare (in /home/n/Documents/imazen/imageflow/target/debug/visuals-289e0d4add8b75f1)
==13229==    by 0x5F3E17: flow_bitmap_bgra_test_compare_to_record (in /home/n/Documents/imazen/imageflow/target/debug/visuals-289e0d4add8b75f1)
==13229==    by 0x267B2B: visuals::compare::h14429884799746c9 (visuals.rs:116)
==13229==    by 0x2693A6: visuals::test_fill_rect_original::h451617aee4fd81e2 (visuals.rs:189)
==13229==    by 0x57A69E: {{closure}} (lib.rs:1265)
==13229==    by 0x57A69E: _$LT$F$u20$as$u20$test..FnBox$LT$T$GT$$GT$::call_box::h139af31b37861296 (lib.rs:141)
==13229==    by 0x5D5E1A: __rust_maybe_catch_panic (lib.rs:97)
==13229==    by 0x56F92F: try<(),std::panic::AssertUnwindSafe<closure>> (panicking.rs:332)
==13229==    by 0x56F92F: catch_unwind<std::panic::AssertUnwindSafe<closure>,()> (panic.rs:351)
==13229==    by 0x56F92F: {{closure}} (lib.rs:1210)
==13229==    by 0x56F92F: call_once<(),closure> (panic.rs:295)
==13229==    by 0x56F92F: std::panicking::try::do_call::he0c0a6db23f4cacc (panicking.rs:356)
==13229==    by 0x5D5E1A: __rust_maybe_catch_panic (lib.rs:97)
==13229==    by 0x575C32: try<(),std::panic::AssertUnwindSafe<closure>> (panicking.rs:332)
==13229==    by 0x575C32: catch_unwind<std::panic::AssertUnwindSafe<closure>,()> (panic.rs:351)
==13229==    by 0x575C32: {{closure}}<closure,()> (mod.rs:287)
==13229==    by 0x575C32: _$LT$F$u20$as$u20$alloc..boxed..FnBox$LT$A$GT$$GT$::call_box::hd0908040f09af183 (boxed.rs:595)
==13229==    by 0x5CBE34: call_once<(),()> (boxed.rs:605)
==13229==    by 0x5CBE34: start_thread (thread.rs:21)
==13229==    by 0x5CBE34: std::sys::imp::thread::Thread::new::thread_start::h990fb082eb5abe34 (thread.rs:84)
==13229==    by 0x5550183: start_thread (pthread_create.c:312)
==13229==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==13229== 
{
   <insert_a_suppression_name_here>
   Memcheck:Addr1
   fun:strcmp
   fun:visual_compare
   fun:flow_bitmap_bgra_test_compare_to_record
   fun:_ZN7visuals7compare17h14429884799746c9E
   fun:_ZN7visuals23test_fill_rect_original17h451617aee4fd81e2E
   fun:{{closure}}
   fun:_ZN42_$LT$F$u20$as$u20$test..FnBox$LT$T$GT$$GT$8call_box17h139af31b37861296E
   fun:__rust_maybe_catch_panic
   fun:try<(),std::panic::AssertUnwindSafe<closure>>
   fun:catch_unwind<std::panic::AssertUnwindSafe<closure>,()>
   fun:{{closure}}
   fun:call_once<(),closure>
   fun:_ZN3std9panicking3try7do_call17he0c0a6db23f4caccE
   fun:__rust_maybe_catch_panic
   fun:try<(),std::panic::AssertUnwindSafe<closure>>
   fun:catch_unwind<std::panic::AssertUnwindSafe<closure>,()>
   fun:{{closure}}<closure,()>
   fun:_ZN50_$LT$F$u20$as$u20$alloc..boxed..FnBox$LT$A$GT$$GT$8call_box17hd0908040f09af183E
   fun:call_once<(),()>
   fun:start_thread
   fun:_ZN3std3sys3imp6thread6Thread3new12thread_start17h990fb082eb5abe34E
   fun:start_thread
}
==13229== 
==13229== Process terminating with default action of signal 11 (SIGSEGV)
==13229==  Access not within mapped region at address 0x0
==13229==    at 0x4C2EAA1: strcmp (vg_replace_strmem.c:842)
==13229==    by 0x5F36EF: visual_compare (in /home/n/Documents/imazen/imageflow/target/debug/visuals-289e0d4add8b75f1)
==13229==    by 0x5F3E17: flow_bitmap_bgra_test_compare_to_record (in /home/n/Documents/imazen/imageflow/target/debug/visuals-289e0d4add8b75f1)
==13229==    by 0x267B2B: visuals::compare::h14429884799746c9 (visuals.rs:116)
==13229==    by 0x2693A6: visuals::test_fill_rect_original::h451617aee4fd81e2 (visuals.rs:189)
==13229==    by 0x57A69E: {{closure}} (lib.rs:1265)
==13229==    by 0x57A69E: _$LT$F$u20$as$u20$test..FnBox$LT$T$GT$$GT$::call_box::h139af31b37861296 (lib.rs:141)
==13229==    by 0x5D5E1A: __rust_maybe_catch_panic (lib.rs:97)
==13229==    by 0x56F92F: try<(),std::panic::AssertUnwindSafe<closure>> (panicking.rs:332)
==13229==    by 0x56F92F: catch_unwind<std::panic::AssertUnwindSafe<closure>,()> (panic.rs:351)
==13229==    by 0x56F92F: {{closure}} (lib.rs:1210)
==13229==    by 0x56F92F: call_once<(),closure> (panic.rs:295)
==13229==    by 0x56F92F: std::panicking::try::do_call::he0c0a6db23f4cacc (panicking.rs:356)
==13229==    by 0x5D5E1A: __rust_maybe_catch_panic (lib.rs:97)
==13229==    by 0x575C32: try<(),std::panic::AssertUnwindSafe<closure>> (panicking.rs:332)
==13229==    by 0x575C32: catch_unwind<std::panic::AssertUnwindSafe<closure>,()> (panic.rs:351)
==13229==    by 0x575C32: {{closure}}<closure,()> (mod.rs:287)
==13229==    by 0x575C32: _$LT$F$u20$as$u20$alloc..boxed..FnBox$LT$A$GT$$GT$::call_box::hd0908040f09af183 (boxed.rs:595)
==13229==    by 0x5CBE34: call_once<(),()> (boxed.rs:605)
==13229==    by 0x5CBE34: start_thread (thread.rs:21)
==13229==    by 0x5CBE34: std::sys::imp::thread::Thread::new::thread_start::h990fb082eb5abe34 (thread.rs:84)
==13229==    by 0x5550183: start_thread (pthread_create.c:312)
==13229==  If you believe this happened as a result of a stack
==13229==  overflow in your program's main thread (unlikely but
==13229==  possible), you can try to increase the size of the
==13229==  main thread stack using the --main-stacksize= flag.
==13229==  The main thread stack size used in this run was 8388608.
./valgrind_existing.sh: line 76: 13229 Segmentation fault      (core dumped) valgrind -q --error-exitcode=9 --gen-suppressions=all ../visuals-289e0d4add8b75f1
n@n
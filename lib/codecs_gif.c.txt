#include <stdio.h>
#include "gif_lib.h"
#include "imageflow_private.h"
#include "job.h"
#include "lcms2.h"
#include "codecs.h"


//Gif - read X bytes into buffer at a time, return count copied.
//Gif - wrtie
//    /* func type to read gif data from arbitrary sources (TVT) */
//    typedef int (*InputFunc) (GifFileType *, GifByteType *, int);
//
///* func type to write gif data to arbitrary targets.
// * Returns count of bytes written. (MRB)
// */
//    typedef int (*OutputFunc) (GifFileType *, const GifByteType *, int);
////
////
//
//    static void
//    _ReadProc(png_structp png_ptr, unsigned char *data, png_size_t size) {
//        pfi_ioStructure pfio = (pfi_ioStructure)png_get_io_ptr(png_ptr);
//        unsigned n = pfio->s_io->read_proc(data, (unsigned int)size, 1, pfio->s_handle);
//        if(size && (n == 0)) {
//            throw "Read error: invalid or corrupted PNG file";
//        }
//    }
//
//    static void
//    _WriteProc(png_structp png_ptr, unsigned char *data, png_size_t size) {
//        pfi_ioStructure pfio = (pfi_ioStructure)png_get_io_ptr(png_ptr);
//        pfio->s_io->write_proc(data, (unsigned int)size, 1, pfio->s_handle);
//    }



//context errors must be translated to codec-specific exit flags for every codec



typedef enum flow_job_gif_decoder_stage {
    flow_job_gif_decoder_stage_Null = 0,
    flow_job_gif_decoder_stage_Failed,
    flow_job_gif_decoder_stage_NotStarted,
    flow_job_gif_decoder_stage_BeginRead,
    flow_job_gif_decoder_stage_FinishRead,
} flow_job_gif_decoder_stage;

typedef void (*read_function_data_cleanup)(flow_context * c, void ** read_function_data);

struct flow_job_read_function_data{
    void* file_bytes;
    size_t file_bytes_count;
    size_t cursor;
};

struct flow_job_gif_decoder_state {
    GifFileType * gif;
    size_t row_stride;
    size_t w;
    size_t h;


    InputFunc read_function;
    struct flow_job_read_function_data * read_function_data;
    read_function_data_cleanup read_data_cleanup;

        uint8_t* pixel_buffer;
    size_t pixel_buffer_size;
//    uint8_t** pixel_buffer_row_pointers;
    flow_context* context;
    flow_job_gif_decoder_stage stage;


};



bool setup_read_function_data_for_buffer(flow_context *c, void ** read_function_data, void * file_bytes, size_t file_bytes_count){
    struct flow_job_read_function_data * data = (struct flow_job_read_function_data *)FLOW_malloc(c, sizeof(struct flow_job_read_function_data));
    if (data == NULL){
        FLOW_error(c, flow_status_Out_of_memory);
        return false;
    }
    data->file_bytes = file_bytes;
    data->file_bytes_count = file_bytes_count;
    data->cursor = 0;
    *read_function_data = data;
    return true;
}


int flow_job_gif_read_function (GifFileType * gif, GifByteType * buffer, int bytes_please){
    struct flow_job_gif_decoder_state * state = (struct flow_job_gif_decoder_state *)gif->UserData;

    uint8_t * bytes = (uint8_t *) state->read_function_data->file_bytes;
    size_t length = state->read_function_data->file_bytes_count;
    size_t old_cursor = state->read_function_data->cursor;
    if (old_cursor >= length) return 0; //No bytes left
    size_t new_cursor = old_cursor+ bytes_please;
    if (new_cursor > length) new_cursor = length;
    memcpy(buffer, &bytes[state->read_function_data->cursor], new_cursor - old_cursor);
    state->read_function_data->cursor = new_cursor;
    return new_cursor - old_cursor;
}



static bool flow_job_gif_decoder_reset(flow_context* c, struct flow_job_gif_decoder_state* state)
{
    if (state->stage == flow_job_gif_decoder_stage_FinishRead) {
        //FLOW_free(c, state->pixel_buffer);
    }
    if (state->stage == flow_job_gif_decoder_stage_Null) {
        state->gif = NULL;

    } else {

        if (state->gif != NULL) {
            int error_code = 0;
            if (DGifCloseFile(state->gif, &error_code) != GIF_OK){
                FLOW_error_msg(c, flow_status_Image_decoding_failed, "Failed to close GifFileType: %s", GifErrorString(error_code));
                return false;
            }
            state->gif = NULL;
        }

    }
    state->row_stride = 0;
    state->context = c;
    state->w = 0;
    state->h = 0;
    state->stage = flow_job_gif_decoder_stage_NotStarted;
    return true;
}



static bool flow_job_gif_decoder_BeginRead(flow_context* c, struct flow_job_gif_decoder_state* state)
{
    if (state->stage != flow_job_gif_decoder_stage_NotStarted) {
        FLOW_error(c, flow_status_Invalid_internal_state);
        return false;
    }
    if (!flow_job_gif_decoder_reset(c, state)) {
        state->stage = flow_job_gif_decoder_stage_Failed;
        FLOW_error_return(c);
    }
    state->stage = flow_job_gif_decoder_stage_BeginRead;

    int error = 0;
    state->gif = DGifOpen(state, flow_job_gif_read_function, &error);

    if (error != D_GIF_SUCCEEDED){
        FLOW_error_msg(c, flow_status_Image_decoding_failed, "Failed to open gif: DGifOpen failed with error '%s'", GifErrorString(error));
        return false;
    }

    if (state->gif == NULL) {
        FLOW_error(c, flow_status_Out_of_memory);
        flow_job_gif_decoder_reset(c, state);
        state->stage = flow_job_gif_decoder_stage_Failed;
        return false;
    }
    state->w = state->gif->SWidth;
    state->h = state->gif->SHeight;

    return true;
}

static bool flow_job_gif_decoder_FinishRead(flow_context* c, struct flow_job_gif_decoder_state* state)
{
    if (state->stage != flow_job_gif_decoder_stage_BeginRead) {
        FLOW_error(c, flow_status_Invalid_internal_state);
        return false;
    }
    // We let the caller create the buffer
    //    state->pixel_buffer =  (gif_bytep)FLOW_calloc (c, state->pixel_buffer_size, sizeof(gif_bytep));
    if (state->pixel_buffer == NULL) {
        flow_job_gif_decoder_reset(c, state);
        state->stage = flow_job_gif_decoder_stage_Failed;
        FLOW_error(c, flow_status_Out_of_memory);
        return false;
    }

    state->stage = flow_job_gif_decoder_stage_FinishRead;

    int error_code = 0;
    if (DGifSlurp(state->gif) != GIF_OK){
        FLOW_error_msg(c, flow_status_Image_decoding_failed, "Failed to open gif: DGifOpen failed with error '%s'", GifErrorString(state->gif->Error));
        return false;
    }


    return true;
}


void* flow_job_codecs_aquire_decode_gif_on_buffer(flow_context* c, struct flow_job* job,
                                                   struct flow_job_resource_buffer* buffer)
{
    // flow_job_gif_decoder_state
    if (buffer->codec_state == NULL) {
        struct flow_job_gif_decoder_state* state
                = (struct flow_job_gif_decoder_state*)FLOW_malloc(c, sizeof(struct flow_job_gif_decoder_state));
        if (state == NULL) {
            FLOW_error(c, flow_status_Out_of_memory);
            return NULL;
        }
        state->stage = flow_job_gif_decoder_stage_Null;

        if (!flow_job_gif_decoder_reset(c, state)) {
            FLOW_add_to_callstack(c);
            return NULL;
        }
        if (!setup_read_function_data_for_buffer(c, &state->read_function_data, buffer->buffer, buffer->buffer_size)){
            FLOW_add_to_callstack(c);
            return NULL;
        }

        buffer->codec_state = (void*)state;
    }
    return buffer->codec_state;
}

bool flow_job_codecs_gif_get_info(flow_context* c, struct flow_job* job, void* codec_state,
                                   struct decoder_frame_info* decoder_frame_info_ref)
{
    struct flow_job_gif_decoder_state* state = (struct flow_job_gif_decoder_state*)codec_state;
    if (state->stage < flow_job_gif_decoder_stage_BeginRead) {
        if (!flow_job_gif_decoder_BeginRead(c, state)) {
            FLOW_error_return(c);
        }
    }
    decoder_frame_info_ref->w = state->w;
    decoder_frame_info_ref->h = state->h;
    decoder_frame_info_ref->format = flow_bgra32; // state->channels == 1 ? flow_gray8 : flow_bgr24;
    return true;
}

bool flow_job_codecs_gif_read_frame(flow_context* c, struct flow_job* job, void* codec_state, flow_bitmap_bgra* canvas)
{
    struct flow_job_gif_decoder_state* state = (struct flow_job_gif_decoder_state*)codec_state;
    if (state->stage == flow_job_gif_decoder_stage_BeginRead) {
        state->pixel_buffer = canvas->pixels;
        state->pixel_buffer_size = canvas->stride * canvas->h;
        if (!flow_job_gif_decoder_FinishRead(c, state)) {
            FLOW_error_return(c);
        }


        return true;
    } else {
        FLOW_error(c, flow_status_Invalid_internal_state);
        return false;
    }
}



void* flow_job_codecs_aquire_encode_gif_on_buffer(flow_context* c, struct flow_job* job,
                                                   struct flow_job_resource_buffer* buffer)
{
    // flow_job_gif_decoder_state
    if (buffer->codec_state == NULL) {
        struct flow_job_gif_encoder_state* state
                = (struct flow_job_gif_encoder_state*)FLOW_malloc(c, sizeof(struct flow_job_gif_encoder_state));
        if (state == NULL) {
            FLOW_error(c, flow_status_Out_of_memory);
            return NULL;
        }
        state->buffer = NULL;
        state->size = 0;
        state->context = c;
        state->output_resource = buffer;

        buffer->codec_state = (void*)state;
    }
    return buffer->codec_state;
}

bool flow_job_codecs_gif_write_frame(flow_context* c, struct flow_job* job, void* codec_state, flow_bitmap_bgra* frame)
{
    struct flow_job_gif_encoder_state* state = (struct flow_job_gif_encoder_state*)codec_state;
    state->buffer = NULL;
    state->size = 0;
    state->context = c;

    state->cinfo.err = gif_std_error(&state->error_mgr);
    state->error_mgr.error_exit = gif_encode_error_exit;

    if (setjmp(state->error_handler_jmp)) {
        // Execution comes back to this point if an error happens
        // We assume that the handler already set the context error
        return false;
    }

    gif_create_compress(&state->cinfo);

    gif_mem_dest(&state->cinfo, (unsigned char**)&state->buffer, &state->size);

    state->cinfo.in_color_space = JCS_EXT_BGRA;
    state->cinfo.image_height = frame->h;
    state->cinfo.image_width = frame->w;
    state->cinfo.input_components = 4;
    state->cinfo.optimize_coding = true;

    gif_set_defaults(&state->cinfo);

    int quality = 90;

    gif_set_quality(&state->cinfo, quality, TRUE /* limit to baseline-JPEG values */);

    gif_simple_progression(&state->cinfo);

    gif_start_compress(&state->cinfo, TRUE);

    uint8_t** rows = flow_job_create_row_pointers(c, frame->pixels, frame->stride * frame->h, frame->stride, frame->h);
    if (rows == NULL) {
        FLOW_add_to_callstack(c);
        gif_destroy_compress(&state->cinfo);
        return false;
    }

    (void)gif_write_scanlines(&state->cinfo, rows, frame->h);

    gif_finish_compress(&state->cinfo);

    gif_destroy_compress(&state->cinfo);

    if (state->error_mgr.num_warnings > 0) {
        FLOW_error(c, flow_status_Invalid_internal_state);
        return false;
    }

    // Copy the final result to the output resource, if it exists.
    if (state->output_resource != NULL) {
        state->output_resource->buffer = state->buffer;
        state->output_resource->buffer_size = state->size;
    }

    return true;
}
